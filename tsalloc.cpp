#include "tsalloc.hpp"

#if (__cplusplus >= 201703L) // C++17 and higher

/**
 * @file tsalloc.cpp
 * @brief Thread-safe memory allocator, supports C++17 standard and higher.
 * The module interface placed in 'tsa::' namespace.
 * 'cstdint' defined in header.
 */

#ifdef  __linux__ 
#include <unistd.h>
#endif // __linux__ 

#include <list>
#include <iostream>
#include <functional>
#include <mutex>

namespace tsa {
    /// Mutex to lock in the alloc(size_t) critical section.
    std::mutex allocMutex;
    /// Mutex to lock in the free() critical section.
    std::mutex freeMutex;
    /// Mutex to lock in the printBlocks() critical section.
    std::mutex printMutex;

    /**
     * @brief Makes machine word boundary during allocation via formula.
     * @param x Takes the bytes number generated by sizeof(type) function.
     * @return Returns alligned amount of bits.
     */
    size_t align(size_t x) {
        return (x + sizeof(word_t) - 1) & ~(sizeof(word_t) - 1);
    }

    /**
     * @brief Represents a block of memory in the memory management system.
     * The Block class for a block of memory in the memory management system.
     * Consts of block size, allocation status, and links to the next block.
     */
    struct Block final {
        size_t size;    /// The size of the block.
        bool used;      /// Whether this block is allocated.
        Block* next;    /// Pointer to the next block in the list.
        word_t data[1]; /// Payload pointer.
    };

    /**
     * @class SearchMode
     * for the further expansion of the memory collector algorithm.
     */
    enum class SearchMode {
        SEGREGATED_LIST, 
        SEARCH_MODE_SIZE
    };

    /// Heap start. Initialized on first allocation.
    static Block* heapStart = nullptr;
    /// Current heap top. Updates on each allocation.
    static auto top = heapStart;
    /// Previously found block. Updates in 'nextFit()'.
    static Block* searchStart = heapStart;
    /// Current memory collector algorithm.
    static auto searchMode = SearchMode::SEGREGATED_LIST;
    /// Consists of freed blocks after 'free()' usage to reuse them letter.
    static std::list<Block*> free_list;

    Block* segregatedLists[] = {
        nullptr,   //   8
        nullptr,   //  16
        nullptr,   //  32
        nullptr,   //  64
        nullptr,   // 128
    };

    Block* segregatedTops[] = {
        nullptr,   //   8
        nullptr,   //  16
        nullptr,   //  32
        nullptr,   //  64
        nullptr,   // 128
    };

    /**
     * @brief Reserves an addition space for the memory block structre.
     *
     * Since the `word_t data[1]` already allocates one word inside the Block
     * structure, we decrease it from the size request: if a user allocates
     * only one word, it's fully in the Block struct.
     * @param size Takes the bytes number.
     * @return Returns total allocation size.
     */
    size_t allocSize(size_t size) {
        return sizeof(Block) + size - sizeof(std::declval<Block>().data);
    }

    /**
     * @brief Requests memory from OS.
     * @param size Takes the bytes number.
     * @return Returns generated block of memory.
     */
    Block* requestFromOS(size_t size) {
#ifdef  __linux__ 

        auto block = (Block*)sbrk(0);
        if (sbrk(allocSize(size)) == (void*)-1) {
            return nullptr;
        }

        return block;


#endif
    }

    /**
     * @brief Splits the block on two.
     * @param block Generated block of memory.
     * @param size Takes the bytes number.
     * @return Returns the pointer to the smaller sub-block.
     */
    Block* split(Block* block, size_t size) {
        auto freePart = (Block*)((char*)block + allocSize(size));
        freePart->size = block->size - allocSize(size);
        freePart->used = false;
        freePart->next = block->next;

        block->size = size;
        block->next = freePart;

        return block;
    }

    /**
     * @brief Checks the size of block and the possibility to be splitted.
     * @param block Generated block of memory.
     * @param size Takes the bytes number.
     * @return Returns true if can be splitted, false otherwise.
     */
    bool canSplit(Block* block, size_t size) {
        return (int)(allocSize(block->size) - size) >= (int)sizeof(Block);
    }


    /**
     * @brief Allocates a block from the list, splitting if needed.
     * @param block Generated block of memory.
     * @param size The bytes number.
     * @return Returns the pointer to the block.
     */
    Block* listAllocate(Block* block, size_t size) {
        if (searchMode != SearchMode::SEGREGATED_LIST && canSplit(block, size)) {
            block = split(block, size);
        }

        block->used = true;
        block->size = size;

        return block;
    }

    /**
     * @brief Gets bucket number from segregatedLists based on the size.
     * @param size The bytes number.
     * @return Returns the bucket number.
     */
    int getBucket(size_t size) {
        return size / sizeof(word_t) - 1;
    }

    /**
     * @brief First-fit algorithm.
     * @param size The bytes number.
     * @return Returns the pointer to the block, otherwise nullptr.
     */
    Block* firstFit(size_t size) { // First-fit algorithm
        auto block = heapStart;

        while (block != nullptr) {
            if (block->used || block->size < size) {
                block = block->next;
                continue;
            }

            return listAllocate(block, size);
        }

        return nullptr;
    }

    /**
     * @brief Segregated fit algorithm.
     * @param size The bytes number.
     * @return Returns the pointer to the block.
     */
    Block* segregatedFit(size_t size) { // Segregated fit algorithm
        auto bucket = getBucket(size);
        auto originalHeapStart = heapStart;

        heapStart = segregatedLists[bucket];

        auto block = firstFit(size);

        heapStart = originalHeapStart;
        return block;
    }

    /**
     * @brief Coalesces two adjacent blocks.
     * @param block The pointer to the block.
     * @return Returns the pointer to the united blocks.
     */
    Block* coalesce(Block* block) {
        if (!block->next->used) {
            if (block->next == top) {
                top = block;
            }

            block->size += block->next->size;
            block->next = block->next->next;
        }
        return block;
    }

    /**
     * @brief Checks the ability to unite two blocks.
     * @param block Generated block of memory.
     * @return Returns true if can be united, false otherwise.
     */
    bool canCoalesce(Block* block) { 
        return block->next && !block->next->used; 
    }

    /**
     * @brief Return geader to frees the previously allocated block.
     * @param data Allocated data.
     * @return Returns object header.
     */
    Block* getHeader(word_t* data) {
        return (Block*)((char*)data + sizeof(std::declval<Block>().data) -
            sizeof(Block));
    }

    /// Resets the heap to the original position.
    void resetHeap() {
        if (heapStart == nullptr) {
            return;
        }

#ifdef  __linux__ 

        brk(heapStart);

#endif

        heapStart = nullptr;
        top = nullptr;
        searchStart = nullptr;
    }

    word_t* alloc(size_t size) {
        std::scoped_lock allocScopeLock {allocMutex, freeMutex, printMutex };

        size = align(size);

        if (auto block = segregatedFit(size)) {
            return block->data;
        }

        auto block = requestFromOS(size);

        block->size = size;
        block->used = true;

        if (searchMode == SearchMode::SEGREGATED_LIST) {
            auto bucket = getBucket(size);
            if (segregatedLists[bucket] == nullptr) {
                segregatedLists[bucket] = block;
            }
            if (segregatedTops[bucket] != nullptr) {
                segregatedTops[bucket]->next = block;
            }
            segregatedTops[bucket] = block;
        }
        else {
            if (heapStart == nullptr) {
                heapStart = block;
            }
            if (top != nullptr) {
                top->next = block;
            }
            top = block;
        }

        return block->data;
    }

    void free(word_t* data) {
        std::scoped_lock freeScopeLock {allocMutex, freeMutex, printMutex};
        auto block = getHeader(data);
        if (searchMode != SearchMode::SEGREGATED_LIST && canCoalesce(block)) {
            block = coalesce(block);
        }
        block->used = false;
    }

    void visit(const std::function<void(Block*)>& callback) {
        auto block = heapStart;
        while (block != nullptr) {
            callback(block);
            block = block->next;
        }
    }

    /// Traverses the heap.
    void segregatedTraverse(const std::function<void(Block*)>& callback) {
        for (const auto& block : segregatedLists) {
            auto originalHeapStart = heapStart;
            heapStart = block;
            visit(callback);
            heapStart = originalHeapStart;
        }
    }

    ///  Traverses the heap.
    void traverse(const std::function<void(Block*)>& callback) {
        if (searchMode == SearchMode::SEGREGATED_LIST) {
            return segregatedTraverse(callback);
        }
        visit(callback);
    }

    void printBlocks() {
        std::scoped_lock printScopeLock {allocMutex, freeMutex, printMutex};
        traverse([](Block* block) {
            std::cout << "[" << block->size << ", " << block->used << "] ";
            });
        std::cout << "\n";
    }
}

#endif // (__cplusplus >= 201703L)